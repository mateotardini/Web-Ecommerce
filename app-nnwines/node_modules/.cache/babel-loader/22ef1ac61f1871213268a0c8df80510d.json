{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\mateo\\\\Desktop\\\\React\\\\react-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\mateo\\\\Desktop\\\\React\\\\react-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\nexport var ImageUriCache = /*#__PURE__*/function () {\n  function ImageUriCache() {\n    _classCallCheck(this, ImageUriCache);\n  }\n\n  _createClass(ImageUriCache, null, [{\n    key: \"has\",\n    value: function has(uri) {\n      var entries = ImageUriCache._entries;\n      var isDataUri = dataUriPattern.test(uri);\n      return isDataUri || Boolean(entries[uri]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(uri) {\n      var entries = ImageUriCache._entries;\n      var lastUsedTimestamp = Date.now();\n\n      if (entries[uri]) {\n        entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n        entries[uri].refCount += 1;\n      } else {\n        entries[uri] = {\n          lastUsedTimestamp: lastUsedTimestamp,\n          refCount: 1\n        };\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(uri) {\n      var entries = ImageUriCache._entries;\n\n      if (entries[uri]) {\n        entries[uri].refCount -= 1;\n      } // Free up entries when the cache is \"full\"\n\n\n      ImageUriCache._cleanUpIfNeeded();\n    }\n  }, {\n    key: \"_cleanUpIfNeeded\",\n    value: function _cleanUpIfNeeded() {\n      var entries = ImageUriCache._entries;\n      var imageUris = Object.keys(entries);\n\n      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n        var leastRecentlyUsedKey;\n        var leastRecentlyUsedEntry;\n        imageUris.forEach(function (uri) {\n          var entry = entries[uri];\n\n          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n            leastRecentlyUsedKey = uri;\n            leastRecentlyUsedEntry = entry;\n          }\n        });\n\n        if (leastRecentlyUsedKey) {\n          delete entries[leastRecentlyUsedKey];\n        }\n      }\n    }\n  }]);\n\n  return ImageUriCache;\n}();\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      // avoid blocking the main thread\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nexport default ImageLoader;","map":null,"metadata":{},"sourceType":"module"}