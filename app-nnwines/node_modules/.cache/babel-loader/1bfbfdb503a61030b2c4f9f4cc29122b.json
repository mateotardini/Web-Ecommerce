{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport _createClass from \"C:\\\\Users\\\\mateo\\\\Desktop\\\\React\\\\react-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:\\\\Users\\\\mateo\\\\Desktop\\\\React\\\\react-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\n\nvar Info = function Info() {\n  _classCallCheck(this, Info);\n\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n};\n\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\n\n\nvar FillRateHelper = /*#__PURE__*/function () {\n  _createClass(FillRateHelper, null, [{\n    key: \"addListener\",\n    value: function addListener(callback) {\n      if (_sampleRate === null) {\n        console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n      }\n\n      _listeners.push(callback);\n\n      return {\n        remove: function remove() {\n          _listeners = _listeners.filter(function (listener) {\n            return callback !== listener;\n          });\n        }\n      };\n    }\n  }, {\n    key: \"setSampleRate\",\n    value: function setSampleRate(sampleRate) {\n      _sampleRate = sampleRate;\n    }\n  }, {\n    key: \"setMinSampleCount\",\n    value: function setMinSampleCount(minSampleCount) {\n      _minSampleCount = minSampleCount;\n    }\n  }]);\n\n  function FillRateHelper(getFrameMetrics) {\n    _classCallCheck(this, FillRateHelper);\n\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  _createClass(FillRateHelper, [{\n    key: \"activate\",\n    value: function activate() {\n      if (this._enabled && this._samplesStartTime == null) {\n        DEBUG && console.debug('FillRateHelper: activate');\n        this._samplesStartTime = global.performance.now();\n      }\n    }\n  }, {\n    key: \"deactivateAndFlush\",\n    value: function deactivateAndFlush() {\n      if (!this._enabled) {\n        return;\n      }\n\n      var start = this._samplesStartTime; // const for flow\n\n      if (start == null) {\n        DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n        return;\n      }\n\n      if (this._info.sample_count < _minSampleCount) {\n        // Don't bother with under-sampled events.\n        this._resetData();\n\n        return;\n      }\n\n      var total_time_spent = global.performance.now() - start;\n\n      var info = _objectSpread(_objectSpread({}, this._info), {}, {\n        total_time_spent: total_time_spent\n      });\n\n      if (DEBUG) {\n        var derived = {\n          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n        };\n\n        for (var key in derived) {\n          derived[key] = Math.round(1000 * derived[key]) / 1000;\n        }\n\n        console.debug('FillRateHelper deactivateAndFlush: ', {\n          derived: derived,\n          info: info\n        });\n      }\n\n      _listeners.forEach(function (listener) {\n        return listener(info);\n      });\n\n      this._resetData();\n    }\n  }, {\n    key: \"computeBlankness\",\n    value: function computeBlankness(props, state, scrollMetrics) {\n      if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n        return 0;\n      }\n\n      var dOffset = scrollMetrics.dOffset,\n          offset = scrollMetrics.offset,\n          velocity = scrollMetrics.velocity,\n          visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n      // we want to capture that.\n\n      this._info.sample_count++;\n      this._info.pixels_sampled += Math.round(visibleLength);\n      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n      var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n      // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n      var now = global.performance.now();\n\n      if (this._anyBlankStartTime != null) {\n        this._info.any_blank_ms += now - this._anyBlankStartTime;\n      }\n\n      this._anyBlankStartTime = null;\n\n      if (this._mostlyBlankStartTime != null) {\n        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n      }\n\n      this._mostlyBlankStartTime = null;\n      var blankTop = 0;\n      var first = state.first;\n\n      var firstFrame = this._getFrameMetrics(first);\n\n      while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n        firstFrame = this._getFrameMetrics(first);\n        first++;\n      } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n      // as blank.\n\n\n      if (firstFrame && first > 0) {\n        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n      }\n\n      var blankBottom = 0;\n      var last = state.last;\n\n      var lastFrame = this._getFrameMetrics(last);\n\n      while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n        lastFrame = this._getFrameMetrics(last);\n        last--;\n      } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n      // footer as blank.\n\n\n      if (lastFrame && last < props.getItemCount(props.data) - 1) {\n        var bottomEdge = lastFrame.offset + lastFrame.length;\n        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n      }\n\n      var pixels_blank = Math.round(blankTop + blankBottom);\n      var blankness = pixels_blank / visibleLength;\n\n      if (blankness > 0) {\n        this._anyBlankStartTime = now;\n        this._info.any_blank_speed_sum += scrollSpeed;\n        this._info.any_blank_count++;\n        this._info.pixels_blank += pixels_blank;\n\n        if (blankness > 0.5) {\n          this._mostlyBlankStartTime = now;\n          this._info.mostly_blank_count++;\n        }\n      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n        this.deactivateAndFlush();\n      }\n\n      return blankness;\n    }\n  }, {\n    key: \"enabled\",\n    value: function enabled() {\n      return this._enabled;\n    }\n  }, {\n    key: \"_resetData\",\n    value: function _resetData() {\n      this._anyBlankStartTime = null;\n      this._info = new Info();\n      this._mostlyBlankStartTime = null;\n      this._samplesStartTime = null;\n    }\n  }]);\n\n  return FillRateHelper;\n}();\n\nexport default FillRateHelper;","map":null,"metadata":{},"sourceType":"module"}